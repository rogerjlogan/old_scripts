import sys
import re
import pprint
import os
import inspect
import string
from datetime import datetime

__PROGRAM_NAME__ = "CYCLETABLE OPTIMIZER"
__AUTHOR__ = "AUTHOR: Roger Logan, LTXCredence Apps Engineer, Houston, TX"
__DATEMODIFIED__ = "LAST MODIFIED: December 3, 2008"
__VERSION__ = "v1.1"
__FILENAME__ = "cycletblopt.py"
__INPUT1_FILENAME__ = "<cycletbl_mod.p>"
__INPUT2_FILENAME__ = "<device_mod.p>"
__OUTPUT1_FILENAME__ = "<cycletbl_mod.p>.new"
__OUTPUT2_FILENAME__ = "pinlist.txt"
__OUTPUT3_FILENAME__ = "analysis.txt"

__DEBUG__ = True
__USE_GROUPS__ = True
__VERBOSE__ = False
__STRIP_COMMENTS__ = False

__vmapset__ = []
__allpingroups__ = []
__xgrps__ = []
__apexpins__ = []
__allcytbls__ = []
__allcytbls_maxlen__ = 0

def lineno():
    """Returns the current line number in our program."""
    return inspect.currentframe().f_back.f_lineno

class TextException(Exception): pass

class Ddict(dict):
    def __init__(self, default=None):
        self.default = default
    def __getitem__(self, key):
        if not self.has_key(key):
            self[key] = self.default()
        return dict.__getitem__(self, key)
#End Ddict()

class PinGroupConverter(object):
    def getPins(self,item):
        pinlist=[]
        for v in self._extract(item):
            pinlist.append(v)
        #End for
        return pinlist
    #End getPins
    def _extract(self,item2chk):
        if item2chk.strip() not in __allpingroups__:
            yield item2chk
        else:
            for item in __allpingroups__[item2chk.strip()]:
                for v in self._extract(item):
                    yield v
                #End for
            #End for
    #End extract()
    def getGroups(self,item,srtd_grps):
        plst=item.split(',')
        for g in srtd_grps:
            if g in __xgrps__:continue
            intsct=filter(lambda x:x in plst,__allpingroups__[g])
            diff=filter(lambda x:x not in __allpingroups__[g],plst)
            if intsct and len(intsct)==len(__allpingroups__[g]):
                diff.append(g)
                item=(',').join(diff)
                plst=diff
        #End for
        return item
    #End getGroups()
#End PinGroupConverter()

def getSrtdGrps_andUPDATEallpingroups():
    """
        create a sorted list of __allpingroups__ by length of each group
        update __allpingroups__ so that each group contains only pins (no groups within groups)
    """
    global __allpingroups__
    def numeric_compare(x,y):
       if x>y:    return 1
       elif x==y: return 0
       else:      return -1 # x<y
    lengths=[]
    allpingroups_pins=Ddict(dict)
    conv=PinGroupConverter()
    for g in __allpingroups__:
        lst=[]
        for pin in __allpingroups__[g]:
            for p in conv.getPins(pin):
                if p not in lst:
                    lst.append(p)
            allpingroups_pins[g]=lst
        #End for
        if len(allpingroups_pins[g]) not in lengths:
            lengths.append(len(allpingroups_pins[g]))
    #End for
    lengths.sort(numeric_compare)
    lengths.reverse()
    apg_pins_srtd=[]
    for l in lengths:
        for g in allpingroups_pins:
            if l==len(allpingroups_pins[g]):
                apg_pins_srtd.append(g)
        #End for
    #End for
    #let's modify __allpingroups__ so that no subgroups are used
    __allpingroups__=allpingroups_pins
    return apg_pins_srtd
#End getSrtdGrps_andUPDATEallpingroups()

def formatOstr(fmts,args):

    #HEADER
    hdr="# This file was auto-generated by '"+__FILENAME__+" "+__VERSION__+"'\n"
    hdr+="# with the following input files: '"+args[0]+"' and '"+args[1]+"'\n"
    hdr+="# "+__AUTHOR__+"'\n"
    hdr+="# DATE RUN: "+str(datetime.today())+"'\n"
    hdr+="# OS: "+str(os.uname())+"\n"

    #BUILD CYCLETABLES FIRST
    grid,cycs='\n','\n\n'
    deps=Ddict(dict)
    num=-1
    for f in fmts:
        d0d1=f.split(',')
        d0,d1=d0d1[0],d0d1[1]
        for tbls in fmts[f]:
            num+=1
            pins=fmts[f][tbls].replace(',','+')
            tblst=tbls.split(',')
            for tbl in tblst:
                if tbl not in deps.keys():
                    deps[tbl]=[]
                deps[tbl].append(num)
            #End for
            row = { 'cycletbl':'WFT_'+str(num)+',','d0':d0+',','d1': d1+',','pins':pins }
            cycs+='\tCycleSetMD( %(cycletbl)-12s %(d0)-20s %(d1)-20s %(pins)s );\n' % row
        #End for
    #End for

    #ANALYSIS GRID (BASED ON CYCLETABLES)
    width=__allcytbls_maxlen__+2
    msb,mid,lsb='','',''
    msbrow,midrow,lsbrow='','',''
    length=len(str(num))
    for i in range(num+1):
        istr=str(i)
        istr=istr.zfill(length)
        istr=istr[::-1] # reverse string
        if num<100 or i<100:msbrow+=' '
        else:msbrow+=istr[2]
        if num<10 or i<10:midrow+=' '
        else:midrow+=istr[1]
        lsbrow += istr[0]
    fmt = '\n%%-%ds|' % width
    blank=fmt % ' '

    grid+='\n# begin inherit list'
    if msbrow.strip():
        grid+=blank+msbrow+'|'
    if midrow.strip():
        grid+=blank+midrow+'|'
    grid+=blank+lsbrow+'|'
    for tbl in deps:
        fmt = '\n%%-%ds[' % width
        grid+=fmt % tbl
        for i in range(num+1):
            if i in deps[tbl]:char='X'
            else:char='.'
            grid+=char
        #End for
        grid+=']'
    #End for
    grid+='\n# end inherit list'
    
    #VECTOR MAP SET
    vmapstr='\n\n'
    for vmaptpl in __vmapset__:
        row = { 'vmap':vmaptpl[0],'field':vmaptpl[1],'pinlist':vmaptpl[2],'base':vmaptpl[3] }
        vmapstr+='\tVectorMapSet( %(vmap)-5s, %(field)-5s, %(pinlist)-5s, %(base)-5s );\n' % row
    
    ostr=hdr+grid+cycs+vmapstr+'\n\n'
    
    return ostr
#End formatOstr()

def strip(string,delim_st,delim_sp='\n',ignore_st=None,ignore_sp=None):
  """This will return 'string' stripped of anything between (and including) 'delim_st' and 'delim_sp'\
  (except when 'delim_sp' is newline) EVEN IF THEY ARE NESTED.  Delimiters can be any string or character\
  (alphanumerics as well as non-alphanumerics).\
  'ignore_st' and 'ignore _sp' allow removal of substrings from string before parsing for nested strings."""
  
  if ignore_st and ignore_sp:
    string=strip(string,ignore_st,ignore_sp)
  
  es_delim_st=re.escape(delim_st) # returns non-alphanumerics backslashed for regex
  es_delim_sp=re.escape(delim_sp) # returns non-alphanumerics backslashed for regex
  
  if delim_sp!='\n':
    # THIS IS A MULTILINE STRING SO WE NEED TO CHECK FOR NESTING
    patrn = re.compile(
      # This is a regex WITHIN a regex
      "("+es_delim_st+      # outer regex start
      "(?:.*?)"+                # inner regex  ?: prevents backreference of inner regex
                                #              .* searches for any char except '\n'(any # of times)
                                #              ? before closing makes this 'lazy' (it will grab FIRST occurance of 'delim_sp')
      es_delim_sp+")",      # outer regex end
      re.DOTALL|            # re.DOTALL overrides '.*' limitation of '\n' described above
      re.VERBOSE)           # re.VERBOSE allows these comments (ignores whitespace including newlines)
  else:
    # THIS IS A SINGLELINE STRING - NO NEED TO CHECK BEYOND NEWLINE
    patrn = re.compile("("+es_delim_st+"(?:.*))")
  while 1:
    strObj = patrn.search(string) # search for 1st occurance of backreferenced pattern (from outer regex defined above)
    if not strObj:break  # no more, we're done
    # found a substring
    substring=strObj.group() # get string from RE object
    if substring.count(delim_st) and delim_st!= delim_sp>1:
      if delim_sp!='\n':
        # remove nested substring (two 'delim_st' and one 'delim_sp')
        strObj = patrn.search(substring,1) # ignore 1st delim_st
      else:
        strObj = patrn.search(substring)
      if strObj:
        substring = strObj.group() # get string from RE object
    string=string.replace(substring,'',1) # only remove that one instance
  return string
#End strip()


#-----------------------------------------------------------------------
#   main
#-----------------------------------------------------------------------
def main():
    global __OUTPUT1_FILENAME__
    global __vmapset__
    global __allpingroups__
    global __xgrps__
    global __apexpins__
    global __allcytbls__
    global __allcytbls_maxlen__
    
    # Get the arguments from the command line, except the first one.
    args = sys.argv[1:]
    if len(args) != 2:
        print "usage: "+__FILENAME__+" "+__INPUT1_FILENAME__+" "+__INPUT2_FILENAME__
        sys.exit(-1)
    
    os.system('clear')
    if __VERBOSE__:
        print '\n\n'
        print __PROGRAM_NAME__
        print __AUTHOR__
        print __DATEMODIFIED__
        print __VERSION__
    print '\n\n'
    
    infile = file(args[0], 'r')
    ctblcont = infile.read()
    infile.close()
    infile = file(args[1], 'r')
    devcont = infile.read()
    infile.close()
    
    __OUTPUT1_FILENAME__=args[0]+'.new'
    out1file = open(__OUTPUT1_FILENAME__, "w")
    out2file = open(__OUTPUT2_FILENAME__, "w")
    if __DEBUG__:
        out3file = open(__OUTPUT3_FILENAME__, "w")

    #all spaces WITHOUT newlines
    ws_patrn = re.compile("([ \t\r\f\v]*)")
    #all spaces WITH newlines
    wsn_patrn = re.compile("(\s*)")
    
    if __STRIP_COMMENTS__:
        ctblcont=strip(ctblcont,'(*','*)')
        ctblcont=strip(ctblcont,'{','}')
        devcont=strip(devcont,'(*','*)')
        devcont=strip(devcont,'{','}')


###############################
#
#      GATHER DATA FROM INPUT FILES
#
###############################

    #GET PINGROUPS
    pinlistset_patrn = re.compile("PinListSet(?:\s*)\((.*?),(.*?)\)",re.DOTALL)
    rawgroups=pinlistset_patrn.findall(devcont)
    __allpingroups__ = Ddict( dict )
    for pingroup,pins in rawgroups:
        #strip leading and trailing spaces
        pingroup=pingroup.strip();
        pins=re.sub(wsn_patrn,'',pins)
        pins=pins.split(',')
        __allpingroups__[pingroup]=pins
    #End for

    #GET EXCLUDED GROUPS
    xgrps_patrn = re.compile("EXCLUDE_THESE_GROUPS(?:\s*)\((.*?)\)",re.DOTALL)
    rawxgrps=xgrps_patrn.findall(devcont)
    for xgrps in rawxgrps:
        #strip leading and trailing spaces
        xgrps=xgrps.strip();
        xgrps=re.sub(wsn_patrn,'',xgrps)
        xgrps=xgrps.split(',')
        for xgrp in xgrps:
            if xgrp not in __xgrps__:
                __xgrps__.append(xgrp)
        #End for
    #End for

    #GET APEX PINLIST (list of ALL device pins IN ORDER)
    vmapset_patrn = re.compile("VectorMapSet(?:\s*)\((.*?),(.*?),(.*?),(.*?)\)",re.DOTALL)
    __vmapset__=vmapset_patrn.findall(ctblcont)
    conv=PinGroupConverter()
    for vmaptpl in __vmapset__:
        for pin in conv.getPins(vmaptpl[2]):
            __apexpins__.append(pin)
        #End for
    #End for

    #CONVERT CyclSet TO CycleSetMD
    p = re.compile("CycleSet(?:\s*)\((?P<cycletable>.*),(?P<dset>.*),(?P<pin>.*)\)")
    ctblcont=p.sub("CycleSetMD (\g<cycletable>,\g<dset>,\g<dset>,\g<pin>)",ctblcont)

    #GET CYCLE TABLES
    cyclesetmd_patrn = re.compile("CycleSetMD(?:\s*)\((.*),(.*),(.*),(.*)\)")
    allcells=cyclesetmd_patrn.findall(ctblcont)
    formats=Ddict(dict)
    i=-1
    for tbl,dset0,dset1,pin in allcells:
        i+=1
        tbl=re.sub(wsn_patrn,'',tbl)
        dset0=re.sub(wsn_patrn,'',dset0)
        dset1=re.sub(wsn_patrn,'',dset1)
        pin=re.sub(wsn_patrn,'',pin)
        pinlist=conv.getPins(pin)
        pinlist_str=','.join(pinlist)
        f=dset0+','+dset1
        if tbl not in __allcytbls__:
            if len(tbl)>__allcytbls_maxlen__:
                __allcytbls_maxlen__=len(tbl)
            __allcytbls__.append(tbl)
        if pinlist_str not in formats[f]:
            formats[f][pinlist_str]=tbl
        else:
            newtbl=formats[f][pinlist_str]+','+tbl
            formats[f][pinlist_str]=newtbl
    #End for

#################
#
#    CONSOLIDATE PINS FOR EACH FORMAT (dset0,dset1)
#    AND ELIMINATE MORE THAN ONE REFERENCE FOR ANY
#    GIVEN CYCLE TABLE PER FORMAT
#    (to see the difference this section makes,
#     uncomment the following lines)
#
#    pprint.pprint(formats,out1file)
#    sys.exit(-1)
#
#################

    #reverse keys(pins) with values(cycletables) so we can reduce number of cycletable references
    fmts=Ddict(dict)
    for f in formats:
        for p_str in formats[f]:
            v=formats[f][p_str]
            if formats[f][p_str] not in fmts[f]:
                fmts[f][v]=p_str
            else:
                newpstr=fmts[f][v]+','+p_str
                fmts[f][v]=newpstr
        #End for
    #End for
    
    for f in fmts:
        xtbls=[]
        for t in fmts[f]:
            tbls=t.split(',')
            cyctbls=Ddict(dict)
            for v in tbls:
                if v not in cyctbls.keys():
                    cyctbls[v]=fmts[f][t]
            #End for
            xtbls.append(cyctbls)
        #End for
        
        tmptbls=Ddict(dict)
        for row in xtbls:
            for t in row:
                if t not in tmptbls.keys():
                    tmptbls[t]=row[t]
                else:

                    intsct=filter(lambda x:x in tmptbls[t].split(','),row[t].split(','))
                    diff1=filter(lambda x:x not in tmptbls[t].split(','),row[t].split(','))
                    diff2=filter(lambda x:x not in row[t].split(','),tmptbls[t].split(','))
                    UNION=intsct+diff1+diff2
                    
                    tmptbls[t]=','.join(UNION)
            #End for
        #End for
        
        #reverse and reduce again
        tmp2tbls=Ddict(dict)
        for t in tmptbls:
            p=tmptbls[t]
            if p not in tmp2tbls.keys():
                tmp2tbls[p]=t
            else:
                tmp2tbls[p]=tmp2tbls[p]+','+t
        #End for
        
        #reverse back
        newtbls=Ddict(dict)
        for p in tmp2tbls:
            t=tmp2tbls[p]
            if t not in newtbls.keys():
                newtbls[t]=p
        #End for

        fmts[f]=newtbls
    #End for

#################
#
#    CONVERT PINS TO AS FEW GROUPS AS POSSIBLE
#
#################
    if __USE_GROUPS__:
        srtd_grps=getSrtdGrps_andUPDATEallpingroups()
        for f in fmts:
            for t in fmts[f]:
                fmts[f][t]=conv.getGroups(fmts[f][t],srtd_grps)
            #End for
        #End for

#################
#
#    PRINT FILES AND EXIT
#
#################

    ostr=formatOstr(fmts,args)

    printstr = "SUCCESS!!! NEW FILES CREATED:\n"+__OUTPUT1_FILENAME__+"\n"+__OUTPUT2_FILENAME__
    if __DEBUG__:
        printstr += "\n"+__OUTPUT3_FILENAME__
    print printstr
    
    out1file.write(ostr)
    out1file.close()

    #create pinlist.txt
#    apexpins_str='\n'.join(__apexpins__)
#    out2file.write(apexpins_str+'\n')
    out2file.write('PINS:'+str(__apexpins__)+'\n')
    out2file.write('GROUPS:'+str(__allpingroups__)+'\n')
    out2file.close()

    if __DEBUG__:
        pprint.pprint(fmts,out3file)
        out3file.close()


#End main()
#-----------------------------------------------------------------------
#     BEGIN MAIN
#-----------------------------------------------------------------------
if __name__ == '__main__':
    main()
